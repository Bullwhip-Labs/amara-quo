// /lib/services/email-service.ts
// Email delivery service using Resend
// Handles sending responses back to original senders

import { Resend } from 'resend'
import { ProcessedEmail } from '@/lib/kv-client'

export interface EmailSendResult {
  success: boolean
  messageId?: string
  error?: string
  sentAt?: string
}

export interface EmailContent {
  subject: string
  to: string
  htmlContent: string
  textContent: string
  replyTo?: string
}

class EmailService {
  private resend: Resend | null = null
  private fromEmail: string
  private fromName: string
  private enabled: boolean
  private testMode: boolean
  private allowedDomains: string[]
  private blockedDomains: string[]

  constructor() {
    // Initialize configuration
    this.fromEmail = process.env.RESEND_FROM_EMAIL || 'amara@example.com'
    this.fromName = process.env.RESEND_FROM_NAME || 'Amara QUO'
    this.enabled = process.env.ENABLE_EMAIL_SENDING === 'true'
    this.testMode = process.env.EMAIL_TEST_MODE === 'true'
    
    // Parse domain filters
    this.allowedDomains = process.env.EMAIL_ALLOWED_DOMAINS?.split(',').map(d => d.trim()) || []
    this.blockedDomains = process.env.EMAIL_BLOCKED_DOMAINS?.split(',').map(d => d.trim()) || ['noreply', 'no-reply', 'donotreply']

    // Initialize Resend client if API key is provided
    const apiKey = process.env.RESEND_API_KEY
    if (apiKey && this.enabled) {
      this.resend = new Resend(apiKey)
      console.log('üìß Email service initialized:', {
        enabled: this.enabled,
        testMode: this.testMode,
        fromEmail: this.fromEmail,
        fromName: this.fromName
      })
    } else {
      console.warn('‚ö†Ô∏è Email service not initialized:', {
        hasApiKey: !!apiKey,
        enabled: this.enabled
      })
    }
  }

  /**
   * Convert markdown to HTML for email
   */
  private markdownToHtml(markdown: string): string {
    let html = markdown
    
    // Basic markdown to HTML conversion
    // Headers
    html = html.replace(/^### (.*$)/gim, '<h3 style="font-size: 16px; margin: 16px 0 8px 0;">$1</h3>')
    html = html.replace(/^## (.*$)/gim, '<h2 style="font-size: 18px; margin: 16px 0 8px 0;">$1</h2>')
    html = html.replace(/^# (.*$)/gim, '<h1 style="font-size: 20px; margin: 16px 0 8px 0;">$1</h1>')
    
    // Bold
    html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    
    // Italic
    html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>')
    
    // Links
    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: #2563eb;">$1</a>')
    
    // Lists - ES2017 compatible approach
    const listLines = html.split('\n')
    const processedLines: string[] = []
    let inList = false
    let listItems: string[] = []
    
    for (const line of listLines) {
      if (line.startsWith('* ')) {
        const item = line.substring(2)
        listItems.push(`<li>${item}</li>`)
        inList = true
      } else {
        if (inList && listItems.length > 0) {
          processedLines.push(`<ul style="margin: 8px 0; padding-left: 20px;">${listItems.join('')}</ul>`)
          listItems = []
          inList = false
        }
        processedLines.push(line)
      }
    }
    
    // Close any remaining list
    if (inList && listItems.length > 0) {
      processedLines.push(`<ul style="margin: 8px 0; padding-left: 20px;">${listItems.join('')}</ul>`)
    }
    
    html = processedLines.join('\n')
    
    // Line breaks
    html = html.replace(/\n\n/g, '</p><p style="margin: 8px 0;">')
    html = html.replace(/\n/g, '<br>')
    
    // Wrap in paragraph tags
    if (!html.startsWith('<')) {
      html = `<p style="margin: 8px 0;">${html}</p>`
    }
    
    return html
  }

  /**
   * Generate HTML email template
   */
  private generateEmailHtml(content: string, originalSubject: string): string {
    const htmlContent = this.markdownToHtml(content)
    
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${originalSubject}</title>
</head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
  <div style="background: linear-gradient(135deg, #7C3AED 0%, #3B82F6 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0; margin-bottom: 20px;">
    <h1 style="margin: 0; font-size: 24px; font-weight: 300; letter-spacing: 2px;">AMARA QUO</h1>
    <p style="margin: 4px 0 0 0; font-size: 12px; opacity: 0.9;">Intelligent Response System</p>
  </div>
  
  <div style="background: white; padding: 20px; border: 1px solid #e5e7eb; border-radius: 0 0 8px 8px;">
    ${htmlContent}
  </div>
  
  <div style="margin-top: 20px; padding: 20px; background: #f9fafb; border-radius: 8px; font-size: 12px; color: #6b7280; text-align: center;">
    <p style="margin: 0;">This is an automated response generated by Amara QUO AI Assistant.</p>
    <p style="margin: 4px 0 0 0;">Original message received: ${new Date().toLocaleString()}</p>
  </div>
</body>
</html>`
  }

  /**
   * Generate plain text version
   */
  private generatePlainText(content: string): string {
    // Strip markdown formatting for plain text
    let text = content
    
    // Remove markdown formatting
    text = text.replace(/\*\*([^*]+)\*\*/g, '$1')
    text = text.replace(/\*([^*]+)\*/g, '$1')
    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1 ($2)')
    text = text.replace(/^#+ /gm, '')
    
    // Add footer
    text += '\n\n---\n'
    text += 'This is an automated response generated by Amara QUO AI Assistant.\n'
    text += `Original message received: ${new Date().toLocaleString()}`
    
    return text
  }

  /**
   * Check if email should be sent based on filters
   */
  private shouldSendToEmail(email: string): { allowed: boolean; reason?: string } {
    // Extract domain from email
    const domain = email.split('@')[1]?.toLowerCase()
    if (!domain) {
      return { allowed: false, reason: 'Invalid email address' }
    }

    // Check blocked domains
    for (const blocked of this.blockedDomains) {
      if (email.toLowerCase().includes(blocked)) {
        return { allowed: false, reason: `Blocked pattern: ${blocked}` }
      }
    }

    // If allowed domains are specified, check if email is in allowed list
    if (this.allowedDomains.length > 0) {
      const isAllowed = this.allowedDomains.some(allowed => 
        domain === allowed || email.toLowerCase().includes(allowed)
      )
      if (!isAllowed) {
        return { allowed: false, reason: 'Domain not in allowed list' }
      }
    }

    return { allowed: true }
  }

  /**
   * Extract clean email address from "Name <email>" format
   */
  private extractEmailAddress(fromField: string): string {
    const match = fromField.match(/<([^>]+)>/)
    return match ? match[1] : fromField
  }

  /**
   * Send email response
   */
  async sendResponse(
    email: ProcessedEmail,
    response: string
  ): Promise<EmailSendResult> {
    try {
      // Check if service is enabled
      if (!this.enabled) {
        console.log('üìß Email sending disabled, skipping')
        return { 
          success: false, 
          error: 'Email sending is disabled' 
        }
      }

      if (!this.resend) {
        return { 
          success: false, 
          error: 'Resend client not initialized' 
        }
      }

      // Extract recipient email
      const toEmail = this.extractEmailAddress(email.from)
      
      // Check if we should send to this email
      const { allowed, reason } = this.shouldSendToEmail(toEmail)
      if (!allowed) {
        console.log(`üìß Email blocked: ${toEmail} - ${reason}`)
        return { 
          success: false, 
          error: `Email blocked: ${reason}` 
        }
      }

      // Generate email content
      const subject = `Re: ${email.subject}`
      const htmlContent = this.generateEmailHtml(response, email.subject)
      const textContent = this.generatePlainText(response)

      // Test mode - just log
      if (this.testMode) {
        console.log('üìß TEST MODE - Email would be sent:')
        console.log({
          to: toEmail,
          subject,
          from: `${this.fromName} <${this.fromEmail}>`,
          contentLength: response.length
        })
        return {
          success: true,
          messageId: `test-${Date.now()}`,
          sentAt: new Date().toISOString()
        }
      }

      // Send via Resend
      console.log(`üìß Sending email to ${toEmail}...`)
      
      const result = await this.resend.emails.send({
        from: `${this.fromName} <${this.fromEmail}>`,
        to: [toEmail],
        subject,
        html: htmlContent,
        text: textContent,
        headers: {
          'X-Entity-Ref-ID': email.id,
        },
        tags: [
          { name: 'email_id', value: email.id },
          { name: 'thread_id', value: email.threadId },
        ]
      })

      if (result.error) {
        console.error('üìß Email send failed:', result.error)
        return {
          success: false,
          error: result.error.message
        }
      }

      console.log(`‚úÖ Email sent successfully: ${result.data?.id}`)
      
      return {
        success: true,
        messageId: result.data?.id,
        sentAt: new Date().toISOString()
      }

    } catch (error) {
      console.error('üìß Email service error:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  }

  /**
   * Send a test email
   */
  async sendTestEmail(toEmail: string): Promise<EmailSendResult> {
    const testEmail: ProcessedEmail = {
      id: 'test-' + Date.now(),
      threadId: 'test-thread',
      subject: 'Test Email from Amara QUO',
      from: toEmail,
      to: this.fromEmail,
      date: new Date().toISOString(),
      snippet: 'This is a test email',
      body: 'This is a test email to verify the email service is working correctly.',
      receivedAt: new Date().toISOString(),
      historyId: 0,
      status: 'completed'
    }

    const testResponse = `
## Test Response from Amara QUO

This is a **test email** to verify that the email service is configured correctly.

### Configuration Status:
- Email service: ${this.enabled ? 'Enabled' : 'Disabled'}
- Test mode: ${this.testMode ? 'Yes' : 'No'}
- From address: ${this.fromEmail}

If you're receiving this email, the configuration is working correctly!

Best regards,  
*Amara QUO AI Assistant*
    `.trim()

    return this.sendResponse(testEmail, testResponse)
  }

  /**
   * Check if email service is configured
   */
  isConfigured(): boolean {
    return this.enabled && !!this.resend
  }

  /**
   * Get current configuration
   */
  getConfiguration() {
    return {
      enabled: this.enabled,
      testMode: this.testMode,
      fromEmail: this.fromEmail,
      fromName: this.fromName,
      hasApiKey: !!process.env.RESEND_API_KEY,
      allowedDomains: this.allowedDomains,
      blockedDomains: this.blockedDomains
    }
  }
}

// Export singleton instance
export const emailService = new EmailService()